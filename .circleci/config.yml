# Use the latest 2.1 version of CircleCI pipeline process engine.
# See: https://circleci.com/docs/2.0/configuration-reference
version: 2.1

description: |
  Pipeline script that:
  1. build, test and deploy Rock Paper Scissors (RPS) application
  2. creates and publishes RPS Docker images to the Docker Hub repository
  3. creates GitHub releases
  Issues & PRs: https://github.com/hokushin118/rps

# We use orbs to provide some codecov tasks and shorten our config.
# Learn more about orbs: https://circleci.com/orbs/
orbs:
  codecov: codecov/codecov@1.0.2

# An executor defines the underlying technology or environment in which to run a job.
executors:
  docker-executor:
    docker:
      # with this image as the primary container; this is where all `steps` will run
      - image: circleci/openjdk:11-jdk
  linux-machine-executor:
    machine:
      # recommended linux image - includes Ubuntu 20.04, docker 19.03.13, docker-compose 1.27.4
      image: ubuntu-2004:202010-01

# Pipeline Parameters
## These parameters are used internally.
parameters:
  main-repo-branch:
    description: "Name of the master branch of the application."
    type: string
    default: "master"
  nexus-repo-branch:
    description: "Name of the branch used for storing artifacts."
    type: string
    default: "nexus-repo"
  workingdir:
    description: "Working directory of the application."
    type: string
    default: "~/rps"
  release-tag-regex:
    description: |
      Regex that matches the SemVer (Semantic Versioning) rules.
      https://rgxdb.com/r/40OZ1HN5
    type: string
    default: |
      /(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)\.(?:0|[1-9]\d*)/

# Several steps in this config use the same, specialized steps.
# Commands can be used to extract a common set of steps into a reusable-block.
# In this case, whenever you see `- restore_cache_cmd` as a "step" in the config below,
# It is executing a command to restore_cache.
commands:
  restore_cache_cmd:
    description: "Runs restore cache steps."
    steps:
      - restore_cache:
          keys:
            # Find a cache corresponding to this specific pom.xml checksum
            # when this file is changed, this key will fail
            - v1-dependencies-{{ checksum "pom.xml" }}
            # Fallback to using the latest cache if no exact match is found
            - v1-dependencies-

  save_cache_cmd:
    description: "Runs save cache steps."
    steps:
      - save_cache:
          paths:
            - ~/.m2
          key: v1-dependencies-{{ checksum "pom.xml" }}

  move_settings_cmd:
    description: |
      Creates settings-security.xml file with master password in the ~/.m2 folder and
      moves settings.xml file to the ~/.m2 folder.
    steps:
      - run:
          name: Moving settings.xml and settings-security.xml files to ~/.m2 folder
          command: |
            sudo chmod +x ./mvnw
            ./mvnw dependency:go-offline
            cp .mvn/wrapper/settings.xml ~/.m2/settings.xml
            chmod 700 ~/.m2/settings.xml
            echo "<settingsSecurity><master>${MAVEN_SECURITY_PASSWORD}</master></settingsSecurity>" > ~/.m2/settings-security.xml

  install_jdk_cmd:
    description: "Installs JDK 11 on Linux machine."
    steps:
      - run:
          name: Installing OpenJDK 11
          command: |
            sudo apt-get update && sudo apt-get install openjdk-11-jdk
            sudo update-alternatives --set java /usr/lib/jvm/java-11-openjdk-amd64/bin/java
            sudo update-alternatives --set javac /usr/lib/jvm/java-11-openjdk-amd64/bin/javac
            java -version

  sonar-scan:
    description: "Code quality and security check with SonarQube."
    steps:
      # Reuse the workspace from the previous job
      - attach_workspace:
          at: << pipeline.parameters.workingdir >>
      - run:
          name: Scaning with Sonar
          command: |
            sudo chmod +x ./mvnw
            ./mvnw verify sonar:sonar -Dsonar.projectKey=$SONAR_PROJECT_KEY
      # Save workspace for subsequent jobs
      - persist_to_workspace:
          root: << pipeline.parameters.workingdir >>
          paths:
            - .

  unit-test:
    description: "Runs application JUnit tests and sends the generated coverage report to Codecov."
    steps:
      # Reuse the workspace from the previous job
      - attach_workspace:
          at: << pipeline.parameters.workingdir >>
      - run:
          name: JUnit testing
          command: |
            sudo chmod +x ./mvnw
            ./mvnw test
      - store_artifacts:
          path: target
      # Uploading generated jacoco code coverage report to codecov
      - codecov/upload:
          file: './target/site/jacoco/jacoco.xml'
          token: $CODECAV_TOKEN
      # Save workspace for subsequent jobs
      - persist_to_workspace:
          root: << pipeline.parameters.workingdir >>
          paths:
            - .

  publish-docker:
    description: "Creates the application Docker image and publishes it to the Docker Hub repository."
    steps:
      # Reuse the workspace from the previous job
      - attach_workspace:
          at: << pipeline.parameters.workingdir >>
      - run:
          name: Creating and publishing Docker image to the Docker Hub repository with jib plugin
          command: |
            ./mvnw compile jib:build -Djib.to.auth.username=${DOCKER_HUB_ID} \
                                     -Djib.to.auth.password=${RPS_DOCKER_HUB_TOKEN} \
                                     -B -DskipTests=true \
                                     -Dbuild.number=${CIRCLE_BUILD_NUM} \
                                     -Dcommit.hash=${CIRCLE_SHA1} \
                                     -Dcircle.workflow.guid=${CIRCLE_WORKFLOW_ID} \
                                     -Dbuild.user=${CIRCLE_PROJECT_USERNAME} \
                                     -Dbuild.repo=${CIRCLE_PROJECT_REPONAME} \
                                     -Pdocker
      # Save workspace for subsequent jobs
      - persist_to_workspace:
          root: << pipeline.parameters.workingdir >>
          paths:
            - .

  deploy-local:
    description: "Deploys generated artifact to the GitHub internal artifactory."
    steps:
      # Reuse the workspace from the previous job
      - attach_workspace:
          at: << pipeline.parameters.workingdir >>
      - run:
          name: Deploying to Internal Artifactory (GitHub) with Maven Deploy plugin
          command: ./mvnw -s ~/.m2/settings.xml deploy
      # Save workspace for subsequent jobs
      - persist_to_workspace:
          root: << pipeline.parameters.workingdir >>
          paths:
            - .

  deploy-github-packages:
    description: "Deploys generated artifact to the GitHub Packages repository."
    steps:
      # Reuse the workspace from the previous job
      - attach_workspace:
          at: << pipeline.parameters.workingdir >>
      - move_settings_cmd
      - run:
          name: Deploying to the GitHub Packages repository with Maven Deploy plugin
          command: ./mvnw deploy -Pgithub
      # Save workspace for subsequent jobs
      - persist_to_workspace:
          root: << pipeline.parameters.workingdir >>
          paths:
            - .

  release-github-packages:
    description: "Publishes application Releases on GitHub repository."
    steps:
      # Reuse the workspace from the previous job
      - attach_workspace:
          at: << pipeline.parameters.workingdir >>
      - run:
          name: Preparing Release
          command: ./mvnw --batch-mode release:prepare
      - run:
          name: Performing Release
          command: ./mvnw --batch-mode release:perform

  checkout-and-build:
    description: "Checkout repository and builds and packages the application."
    steps:
      - checkout # check out source code to working directory
      - restore_cache_cmd
      - move_settings_cmd
      - run:
          name: Packaging application
          command: |
            sudo chmod +x ./mvnw
            ./mvnw clean package -s ~/.m2/settings.xml -Pprod
      - save_cache_cmd
      # Save workspace for subsequent jobs
      - persist_to_workspace:
          root: << pipeline.parameters.workingdir >>
          paths:
            - .

# Define a job (a building block of CI/CD pipeline) to be invoked later in a workflow.
# See: https://circleci.com/docs/2.0/configuration-reference/#jobs
jobs:
  # Specify the execution environment. You can specify an image from Dockerhub or use one of our Convenience Images from CircleCI's Developer Hub.
  # See: https://circleci.com/docs/2.0/configuration-reference/#docker-machine-macos-windows-executor
  build-with-docker:
    executor: docker-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - checkout-and-build

  unit-test-with-docker:
    executor: docker-executor
    working_directory: << pipeline.parameters.workingdir >>
    # Add steps to the job
    # See: https://circleci.com/docs/2.0/configuration-reference/#steps
    steps:
      - unit-test
      - sonar-scan

  publish-with-docker:
    executor: docker-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - publish-docker

  deploy-with-docker:
    executor: docker-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - deploy-github-packages

  release-with-docker:
    executor: docker-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - release-github-packages

  build-with-linux-machine:
    executor: linux-machine-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - install_jdk_cmd
      - checkout-and-build

  unit-test-with-linux-machine:
    executor: linux-machine-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - install_jdk_cmd
      - unit-test
      - sonar-scan

  publish-with-linux-machine:
    executor: linux-machine-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - install_jdk_cmd
      - publish-docker

  deploy-with-linux-machine:
    executor: linux-machine-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - install_jdk_cmd
      - deploy-github-packages

  release-with-linux-machine:
    executor: linux-machine-executor
    working_directory: << pipeline.parameters.workingdir >>
    steps:
      - release-github-packages

# Invoke jobs via workflows
# See: https://circleci.com/docs/2.0/configuration-reference/#workflows
workflows:
  # This job is responsible for building, testing, deploying of the application on Docker container.
  # It also creates the application Docker image and publishes it in the Docker Hub repository.
  build-test-deploy-with-docker:
    jobs:
      - build-with-docker:
          filters:
            branches:
              # Ignore nexus-repo branch
              ignore: << pipeline.parameters.nexus-repo-branch >>

      - unit-test-with-docker:
          requires:
            - build-with-docker
          # execute the job in SonarCloud security context
          context: SonarCloud
          filters:
            branches:
              # Ignore nexus-repo branch
              ignore: << pipeline.parameters.nexus-repo-branch >>

      - publish-with-docker:
          requires:
            - unit-test-with-docker
          filters:
            tags:
              # Only when a git tag is pushed
              only: << pipeline.parameters.release-tag-regex >>
            branches:
              # Only master branch gets published
              only: /^(<< pipeline.parameters.main-repo-branch >>)$/

      - deploy-with-docker:
          requires:
            - unit-test-with-docker
          filters:
            tags:
              # Only when a git tag is pushed
              only: << pipeline.parameters.release-tag-regex >>
            branches:
              # Only master branch gets deployed
              only: /^(<< pipeline.parameters.main-repo-branch >>)$/

      - release-with-docker:
          requires:
            - publish-with-docker
            - deploy-with-docker
          filters:
            tags:
              # Only when a git tag is pushed
              only: << pipeline.parameters.release-tag-regex >>
            branches:
              # Only master branch gets deployed
              only: /^(<< pipeline.parameters.main-repo-branch >>)$/

  # This job is responsible for building, testing, deploying of the application on Linux machine.
  # It also creates the application Docker image and publishes it in the Docker Hub repository.
  build-test-deploy-with-linux-machine:
    jobs:
      - build-with-linux-machine:
          filters:
            branches:
              # Ignore nexus-repo branch
              ignore: << pipeline.parameters.nexus-repo-branch >>

      - unit-test-with-linux-machine:
          requires:
            - build-with-linux-machine
          # execute the job in SonarCloud security context
          context: SonarCloud
          filters:
            branches:
              # Ignore nexus-repo branch
              ignore: << pipeline.parameters.nexus-repo-branch >>

      - publish-with-linux-machine:
          requires:
            - unit-test-with-linux-machine
          filters:
            tags:
              # Only when a git tag is pushed
              only: << pipeline.parameters.release-tag-regex >>
            branches:
              # Only master branch gets published
              only: /^(<< pipeline.parameters.main-repo-branch >>)$/

      - deploy-with-linux-machine:
          requires:
            - unit-test-with-linux-machine
          filters:
            tags:
              # Only when a git tag is pushed
              only: << pipeline.parameters.release-tag-regex >>
            branches:
              # Only master branch gets deployed
              only: /^(<< pipeline.parameters.main-repo-branch >>)$/

      - release-with-linux-machine:
          requires:
            - publish-with-linux-machine
            - deploy-with-linux-machine
          filters:
            tags:
              # Only when a git tag is pushed
              only: << pipeline.parameters.release-tag-regex >>
            branches:
              # Only master branch gets deployed
              only: /^(<< pipeline.parameters.main-repo-branch >>)$/
